{"ast":null,"code":"var _process$env$REACT_AP, _process$env$REACT_AP2, _process$env$REACT_AP3;\n\nimport axios from 'axios';\nimport qs from 'qs';\nimport history from './history';\nimport jwtDecode from 'jwt-decode';\n/* Tipo um Enum, para auxiliar a descodificar o token */\n\nconst tokenKey = 'authData';\n/*\r\nConstante, de Url, para utilizar uma variável de ambiente, compatível com o Netlify, \r\ne caso não esteja definida, através do operador de coalescência (?? no Javascript/Typescript) buscar (à direita) o url padrão para testes locais\r\n*/\n\nexport const BASE_URL = (_process$env$REACT_AP = process.env.REACT_APP_BACKEND_URL) !== null && _process$env$REACT_AP !== void 0 ? _process$env$REACT_AP : 'http://localhost:8080';\n/* Variável de teste para gerar o Authorization (através do algoritmo btoa - base64) q integra o cabeçalho de login (como está no Postman) */\n\nconst CLIENT_ID = (_process$env$REACT_AP2 = process.env.REACT_APP_CLIENT_ID) !== null && _process$env$REACT_AP2 !== void 0 ? _process$env$REACT_AP2 : 'projetopathos';\nconst CLIENT_SECRET = (_process$env$REACT_AP3 = process.env.REACT_APP_CLIENT_SECRET) !== null && _process$env$REACT_AP3 !== void 0 ? _process$env$REACT_AP3 : 'projetopathos123';\n/* Função auxiliar para gerar o código de Authorization  */\n\nconst basicHeader = () => 'Basic ' + window.btoa(CLIENT_ID + ':' + CLIENT_SECRET);\n/* Função para fazer a requisição de login  \r\nO \"loginData\" leva as credenciais do user que vão no corpo da requisição (username e password)\r\n*/\n\n\n/* Nesta função, temos que passar os cabeçalhos mediante o content-type que definimos (ver Postman) \r\n   Podemos utilizar o headers que \"casa\" com o argumento homónimo contido no AxiosRequestConfig\r\n\r\n   Seguidamente, temos que implementar o Body da requisição (ver Postman). Criamos a const data para esse efeito.\r\n   Com o objeto composto por username, password e grant_type, mas convertidos para url_form_encoded. Para tal usamos uma função da \"qs\" \r\n   Também aproveitamos os dados contidos no loginData (através do spread operator) e complementamos com o grant_type \r\n*/\nexport const requestBackendLogin = loginData => {\n  const headers = {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    Authorization: basicHeader()\n  };\n  const data = qs.stringify({ ...loginData,\n    grant_type: 'password'\n  });\n  return axios({\n    method: 'POST',\n    baseURL: BASE_URL,\n    url: '/oauth/token',\n    data,\n    headers\n  });\n};\n/*Já usámos anteriormente - o AxiosRequestConfig tem todas as informações para uma requisição \r\nEsta função, recebe as configurações do axios, complementamos essa info com o BASE_URL e com as credenciais (caso seja true)\r\nonde definimos o valor do \"Authorization\" - q vem do getAuthData - ainda asseguramos que aproveitamos, com o \"spread operator\", o que vem do config.headers\r\nDepois repassamos para o axios, que depois será usado no catálogo (por exemplo)\r\n*/\n\nexport const requestBackend = config => {\n  const headers = config.withCredentials ? { ...config.headers,\n    Authorization: 'Bearer ' + getAuthData().access_token\n  } : config.headers;\n  return axios({ ...config,\n    baseURL: BASE_URL,\n    headers\n  });\n};\n/* Para salvar o objeto do type LoginResponse - dados de autenticação - através da referencia global localStorage e da função da mesma, setItem\r\nIsto será utilizado para fazer requisições autorizadas, por exemplo.\r\n*/\n\nexport const saveAuthData = obj => {\n  localStorage.setItem(tokenKey, JSON.stringify(obj));\n};\n/* Para obter os dados, em String, do localStorage do browser. \r\n\r\nComo queremos um objeto ao invés de uma String, temos q converter através do parse.\r\nTemos q nos certificar que a string não passa um nulo, através de um operador de coalescência para\r\nassegurar que passa um objeto, mesmo q vazio, mas entre aspas, para converter o obj em string e vice-versa depois.\r\n\r\nPara garantir que devolvemos o type correto, fazemos um cast (as LoginResponse) e temos assim uma situação type safe. \r\n*/\n\nexport const getAuthData = () => {\n  var _localStorage$getItem;\n\n  const str = (_localStorage$getItem = localStorage.getItem(tokenKey)) !== null && _localStorage$getItem !== void 0 ? _localStorage$getItem : '{}';\n  return JSON.parse(str);\n};\nexport const removeAuthData = () => {\n  localStorage.removeItem(tokenKey);\n}; // Add a request interceptor\n\naxios.interceptors.request.use(function (config) {\n  // Do something before request is sent\n  return config;\n}, function (error) {\n  // Do something with request error\n  return Promise.reject(error);\n}); // Add a response interceptor\n\naxios.interceptors.response.use(function (response) {\n  // Any status code that lie within the range of 200's cause this function to trigger\n  // Do something with response data\n  return response;\n}, function (error) {\n  // Any status codes that falls outside the range of 2xx cause this function to trigger\n  // Do something with response error\n  if (error.response.status === 401 || error.response.status === 403) {\n    history.push('admin/auth');\n  }\n\n  return Promise.reject(error);\n});\n/*Função para descodificar o token */\n\nexport const getTokenData = () => {\n  try {\n    return jwtDecode(getAuthData().access_token);\n  } catch (error) {\n    return undefined;\n  }\n};\n/** Função para verificar se um User está autenticado\r\n * Essencialmente, recorrendo ao Unix Time Stamp, comparamos se a nossa data atual é menor que o tempo definido no token (ultimos 2 algarismos)\r\n * Se true, o token é válido e o user está autenticado.\r\n * */\n\nexport const isAuthenticated = () => {\n  const tokenData = getTokenData();\n  return tokenData && tokenData.exp * 1000 > Date.now() ? true : false;\n};\n/**Função para determinar os Roles dos users\r\n * Utiliza os \"Enums\" definidos, admin e operator\r\n * e a tokenData -> token que contém info sobre o user, especificamente neste caso, importam os roles que possuem\r\n */\n\nexport const hasAnyRoles = roles => {\n  if (roles.length === 0) {\n    return true;\n  }\n\n  const tokenData = getTokenData();\n\n  if (tokenData !== undefined) {\n    return roles.some(role => tokenData.authorities.includes(role));\n  }\n\n  return false;\n};","map":{"version":3,"names":["axios","qs","history","jwtDecode","tokenKey","BASE_URL","process","env","REACT_APP_BACKEND_URL","CLIENT_ID","REACT_APP_CLIENT_ID","CLIENT_SECRET","REACT_APP_CLIENT_SECRET","basicHeader","window","btoa","requestBackendLogin","loginData","headers","Authorization","data","stringify","grant_type","method","baseURL","url","requestBackend","config","withCredentials","getAuthData","access_token","saveAuthData","obj","localStorage","setItem","JSON","str","getItem","parse","removeAuthData","removeItem","interceptors","request","use","error","Promise","reject","response","status","push","getTokenData","undefined","isAuthenticated","tokenData","exp","Date","now","hasAnyRoles","roles","length","some","role","authorities","includes"],"sources":["C:/ferreiraLapa/projetopathos/frontweb/src/util/requests.ts"],"sourcesContent":["import axios, { AxiosRequestConfig } from 'axios';\r\nimport qs from 'qs';\r\nimport history from './history';\r\nimport jwtDecode from 'jwt-decode';\r\n\r\n/* Tipo um Enum, para auxiliar a descodificar o token */\r\n\r\ntype Role = 'ROLE_ADMIN' | 'ROLE_OPERATOR';\r\n\r\n/* tipo para descodificar o token e verificar o tempo de expiração */\r\nexport type TokenData = {\r\n  exp: number;\r\n  user_name: string;\r\n  authorities: Role[];\r\n};\r\n\r\n/* tipo que define a estrutura de resposta do login */\r\ntype LoginResponse = {\r\n  access_token: string;\r\n  token_type: string;\r\n  expires_in: number;\r\n  scope: string;\r\n  userFirstName: string;\r\n  userId: number;\r\n};\r\n\r\nconst tokenKey = 'authData';\r\n\r\n/*\r\nConstante, de Url, para utilizar uma variável de ambiente, compatível com o Netlify, \r\ne caso não esteja definida, através do operador de coalescência (?? no Javascript/Typescript) buscar (à direita) o url padrão para testes locais\r\n*/\r\nexport const BASE_URL =\r\n  process.env.REACT_APP_BACKEND_URL ?? 'http://localhost:8080';\r\n\r\n/* Variável de teste para gerar o Authorization (através do algoritmo btoa - base64) q integra o cabeçalho de login (como está no Postman) */\r\nconst CLIENT_ID = process.env.REACT_APP_CLIENT_ID ?? 'projetopathos';\r\nconst CLIENT_SECRET = process.env.REACT_APP_CLIENT_SECRET ?? 'projetopathos123';\r\n\r\n/* Função auxiliar para gerar o código de Authorization  */\r\nconst basicHeader = () =>\r\n  'Basic ' + window.btoa(CLIENT_ID + ':' + CLIENT_SECRET);\r\n\r\n/* Função para fazer a requisição de login  \r\nO \"loginData\" leva as credenciais do user que vão no corpo da requisição (username e password)\r\n*/\r\ntype LoginData = {\r\n  username: string;\r\n  password: string;\r\n};\r\n\r\n/* Nesta função, temos que passar os cabeçalhos mediante o content-type que definimos (ver Postman) \r\n   Podemos utilizar o headers que \"casa\" com o argumento homónimo contido no AxiosRequestConfig\r\n\r\n   Seguidamente, temos que implementar o Body da requisição (ver Postman). Criamos a const data para esse efeito.\r\n   Com o objeto composto por username, password e grant_type, mas convertidos para url_form_encoded. Para tal usamos uma função da \"qs\" \r\n   Também aproveitamos os dados contidos no loginData (através do spread operator) e complementamos com o grant_type \r\n*/\r\nexport const requestBackendLogin = (loginData: LoginData) => {\r\n  const headers = {\r\n    'Content-Type': 'application/x-www-form-urlencoded',\r\n    Authorization: basicHeader(),\r\n  };\r\n\r\n  const data = qs.stringify({\r\n    ...loginData,\r\n    grant_type: 'password',\r\n  });\r\n\r\n  return axios({\r\n    method: 'POST',\r\n    baseURL: BASE_URL,\r\n    url: '/oauth/token',\r\n    data,\r\n    headers,\r\n  });\r\n};\r\n\r\n/*Já usámos anteriormente - o AxiosRequestConfig tem todas as informações para uma requisição \r\nEsta função, recebe as configurações do axios, complementamos essa info com o BASE_URL e com as credenciais (caso seja true)\r\nonde definimos o valor do \"Authorization\" - q vem do getAuthData - ainda asseguramos que aproveitamos, com o \"spread operator\", o que vem do config.headers\r\nDepois repassamos para o axios, que depois será usado no catálogo (por exemplo)\r\n*/\r\nexport const requestBackend = (config: AxiosRequestConfig) => {\r\n  const headers = config.withCredentials\r\n    ? {\r\n        ...config.headers,\r\n        Authorization: 'Bearer ' + getAuthData().access_token,\r\n      }\r\n    : config.headers;\r\n\r\n  return axios({ ...config, baseURL: BASE_URL, headers });\r\n};\r\n\r\n/* Para salvar o objeto do type LoginResponse - dados de autenticação - através da referencia global localStorage e da função da mesma, setItem\r\nIsto será utilizado para fazer requisições autorizadas, por exemplo.\r\n*/\r\nexport const saveAuthData = (obj: LoginResponse) => {\r\n  localStorage.setItem(tokenKey, JSON.stringify(obj));\r\n};\r\n\r\n/* Para obter os dados, em String, do localStorage do browser. \r\n\r\nComo queremos um objeto ao invés de uma String, temos q converter através do parse.\r\nTemos q nos certificar que a string não passa um nulo, através de um operador de coalescência para\r\nassegurar que passa um objeto, mesmo q vazio, mas entre aspas, para converter o obj em string e vice-versa depois.\r\n\r\nPara garantir que devolvemos o type correto, fazemos um cast (as LoginResponse) e temos assim uma situação type safe. \r\n*/\r\nexport const getAuthData = () => {\r\n  const str = localStorage.getItem(tokenKey) ?? '{}';\r\n  return JSON.parse(str) as LoginResponse;\r\n};\r\n\r\nexport const removeAuthData = () => {\r\n  localStorage.removeItem(tokenKey);\r\n};\r\n\r\n// Add a request interceptor\r\naxios.interceptors.request.use(\r\n  function (config) {\r\n    // Do something before request is sent\r\n    return config;\r\n  },\r\n  function (error) {\r\n    // Do something with request error\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Add a response interceptor\r\naxios.interceptors.response.use(\r\n  function (response) {\r\n    // Any status code that lie within the range of 200's cause this function to trigger\r\n    // Do something with response data\r\n    return response;\r\n  },\r\n  function (error) {\r\n    // Any status codes that falls outside the range of 2xx cause this function to trigger\r\n    // Do something with response error\r\n    if (error.response.status === 401 || error.response.status === 403) {\r\n      history.push('admin/auth');\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n/*Função para descodificar o token */\r\nexport const getTokenData = (): TokenData | undefined => {\r\n  try {\r\n    return jwtDecode(getAuthData().access_token);\r\n  } catch (error) {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n/** Função para verificar se um User está autenticado\r\n * Essencialmente, recorrendo ao Unix Time Stamp, comparamos se a nossa data atual é menor que o tempo definido no token (ultimos 2 algarismos)\r\n * Se true, o token é válido e o user está autenticado.\r\n * */\r\nexport const isAuthenticated = (): boolean => {\r\n  const tokenData = getTokenData();\r\n  return tokenData && tokenData.exp * 1000 > Date.now() ? true : false;\r\n};\r\n\r\n/**Função para determinar os Roles dos users\r\n * Utiliza os \"Enums\" definidos, admin e operator\r\n * e a tokenData -> token que contém info sobre o user, especificamente neste caso, importam os roles que possuem\r\n */\r\nexport const hasAnyRoles = (roles: Role[]): boolean => {\r\n  if (roles.length === 0) {\r\n    return true;\r\n  }\r\n\r\n  const tokenData = getTokenData();\r\n\r\n  if (tokenData !== undefined) {\r\n    return roles.some((role) => tokenData.authorities.includes(role));\r\n  }\r\n\r\n  return false;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}